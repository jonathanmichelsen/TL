using System;
using System.IO;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Text.RegularExpressions;
using System.Timers;

//Double check screens
//Double check screens
//Double check screens
//Double check screens
//Double check screens
//Double check screens
//Double check screens
//Double check screens

namespace TwistedLight
{
    
    public partial class UserControl1 : UserControl
    {
        int[] calibration1 = new int[65536];
        int[] calibration2 = new int[65536];
        int[] calibration3 = new int[65536];
        int[] calibration4 = new int[65536];

        public UserControl1()
        {
            InitializeComponent();
            InitialCalib();
            redButton.Checked = true;
            calibrationCheck.Checked = true;
        }
        int calibWavelength = 0;
        

        private void InitialCalib()
        {
            if (redButton.Checked == true)
            {
                calibWavelength = 0;
                //System.Diagnostics.Debug.WriteLine(calibWavelength);
            }
            if (orangeButton.Checked == true)
            {
                calibWavelength = 1;
                //System.Diagnostics.Debug.WriteLine(calibWavelength);
            }
            if (greenButton.Checked == true)
            {
                calibWavelength = 2;
                //System.Diagnostics.Debug.WriteLine(calibWavelength);
            }
            //SLM 1  F:\TL_code_june
            //string[] path1 = {@"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3575_at785_DVI.lut", @"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3575_at635_DVI.lut", @"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3575_at532_DVI.lut" };
            string[] path1 = { @"F:\TL_code_june\TwistedLight\slm3575_at785_DVI.lut", @"F:\TL_code_june\TwistedLight\slm3575_at635_DVI.lut", @"F:\TL_code_june\TwistedLight\slm3575_at532_DVI.lut" };
            string input = File.ReadAllText(path1[calibWavelength]);
            int[] col = new int[2];
            string[] temp = new string[2];
            foreach (var row in input.Split('\n'))
            {
                temp = Regex.Split(row, @"[\t]");
                col[0] = int.Parse(temp[0].Trim());
                col[1] = int.Parse(temp[1].Trim());
                calibration1[col[0]] = int.Parse(col[1].ToString());
            }

            //SLM 2
            string[] path2 = { @"F:\TL_code_june\TwistedLight\slm3576_at785_DVI.lut", @"F:\TL_code_june\TwistedLight\slm3576_at635_DVI.lut", @"F:\TL_code_june\TwistedLight\slm3576_at532_DVI.lut" };
            //string[] path2 = { @"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3576_at785_DVI.lut", @"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3576_at635_DVI.lut", @"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3576_at532_DVI.lut" };
            input = File.ReadAllText(path2[calibWavelength]);
            foreach (var row in input.Split('\n'))
            {
                temp = Regex.Split(row, @"[\t]");
                col[0] = int.Parse(temp[0].Trim());
                col[1] = int.Parse(temp[1].Trim());
                calibration2[col[0]] = int.Parse(col[1].ToString());
            }

            //SLM 3
            string[] path3 = { @"F:\TL_code_june\TwistedLight\slm3569_at785_DVI.lut", @"F:\TL_code_june\TwistedLight\slm3569_at635_DVI.lut", @"F:\TL_code_june\TwistedLight\slm3569_at532_DVI.lut" };
            //string[] path3 = { @"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3569_at785_DVI.lut", @"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3569_at635_DVI.lut", @"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3569_at532_DVI.lut" };
            input = File.ReadAllText(path3[calibWavelength]);
            foreach (var row in input.Split('\n'))
            {
                temp = Regex.Split(row, @"[\t]");
                col[0] = int.Parse(temp[0].Trim());
                col[1] = int.Parse(temp[1].Trim());
                calibration3[col[0]] = int.Parse(col[1].ToString());
            }

            //SLM 4
            string[] path4 = { @"F:\TL_code_june\TwistedLight\slm3562_at785_DVI.lut", @"F:\TL_code_june\TwistedLight\slm3562_at635_DVI.lut", @"F:\TL_code_june\TwistedLight\slm3562_at532_DVI.lut" };
            //string[] path4 = { @"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3562_at785_DVI.lut", @"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3562_at635_DVI.lut", @"C:\Users\Polina\Desktop\ControllersVed\CustomControlls\TwistedLight\slm3562_at532_DVI.lut" };
            
            input = File.ReadAllText(path4[calibWavelength]);
            foreach (var row in input.Split('\n'))
            {
                temp = Regex.Split(row, @"[\t]");
                col[0] = int.Parse(temp[0].Trim());
                col[1] = int.Parse(temp[1].Trim());
                calibration4[col[0]] = int.Parse(col[1].ToString());
            }
        }

        public void setCalibration(int number)
        {
            //do a check of which calib is checked, then run the script once, taking from a list of possible choices
        }



        /**
        private void button4_Click(object sender, EventArgs e)
        {
            List<NAudio.Wave.WaveInCapabilities> sources = new List<NAudio.Wave.WaveInCapabilities>();

            for (int i = 0; i < NAudio.Wave.WaveIn.DeviceCount; i++)
            {
                sources.Add(NAudio.Wave.WaveIn.GetCapabilities(i));
            }

            sourceList.Items.Clear();

            foreach (var source in sources)
            {
                ListViewItem item = new ListViewItem(source.ProductName);
                item.SubItems.Add(new ListViewItem.ListViewSubItem(item, source.Channels.ToString()));
                sourceList.Items.Add(item);
            }

        }
        NAudio.Wave.WaveIn sourceStream = null;
        NAudio.Wave.DirectSoundOut waveOut = null;
        NAudio.Wave.WaveFileWriter waveWriter = null;


        private double atanNew(double yVal, double xVal)
        {
            if (Double.IsNaN(Math.Atan2(yVal, xVal)) == true)
            {

                return 0;
            }
            else
            {
                return Math.Atan2(yVal, xVal);
            }
        }
        **/

        private void Calculate_Click(object sender, EventArgs e)
        {
            //Re-calculate calibration based on button 
            
            InitialCalib();

            //parsing for SLM 1 + 2
            int[][] xyDimNum = ParseScanSequenceInt(xyDim.Text);
            double[][] OAMNum = ParseScanSequenceDouble(OAM.Text);
            double[][] phaseIntensityNum = ParseScanSequenceDouble(phaseIntensity.Text);
            double[][] gratingWavelengthNum = ParseScanSequenceDouble(gratingWavelength.Text);
            double[][] maxIntensityNum = ParseScanSequenceDouble(maxIntensity.Text);

            //double[][] innerRadiusNum = ParseScanSequenceDouble(innerRadius.Text);
            //double[][] outerRadiusNum = ParseScanSequenceDouble(outerRadius.Text);

            //parsing for SLM 3, 4
            int[][] dimensionsSlm34 = ParseScanSequenceInt(xyDim34.Text);
            double[][] parameterASlm34 = ParseScanSequenceDouble(d34.Text);
            double[][] parameterBSlm34 = ParseScanSequenceDouble(b34.Text);
            double[][] wavelengthSlm34 = ParseScanSequenceDouble(wavelength34.Text);
            double[][] frequencySlm34 = ParseScanSequenceDouble(f34.Text);
            double[][] amplitudeSlm34 = ParseScanSequenceDouble(amplitude34.Text);

            /**parsing for SLM 4
            int[][] dimensionsSlm4 = ParseScanSequenceInt(xyDim4.Text);
            double[][] parameterASlm4 = ParseScanSequenceDouble(a4.Text);
            double[][] parameterBSlm4 = ParseScanSequenceDouble(b4.Text);

            double[][] wavelengthSlm4 = ParseScanSequenceDouble(wavelength4.Text);
            double[][] frequencySlm4 = ParseScanSequenceDouble(frequency4.Text);
            double[][] alphaSlm4 = ParseScanSequenceDouble(alpha4.Text);
            double[][] amplitudeSlm4 = ParseScanSequenceDouble(amplitude4.Text);**/
            
            //System.Diagnostics.Debug.WriteLine("xyDimNum");
            //System.Diagnostics.Debug.WriteLine(xyDimNum.GetLength(1));
            //System.Diagnostics.Debug.WriteLine("OAMNum");
            //System.Diagnostics.Debug.WriteLine(OAMNum.GetLength(1));
            //System.Diagnostics.Debug.WriteLine("phaseIntensityNum");
            //System.Diagnostics.Debug.WriteLine(phaseIntensityNum.GetLength(1));
            //System.Diagnostics.Debug.WriteLine("gratingWavelengthNum");
            //System.Diagnostics.Debug.WriteLine(gratingWavelengthNum.GetLength(1));
            //System.Diagnostics.Debug.WriteLine("maxIntensityNum");
            //System.Diagnostics.Debug.WriteLine(maxIntensityNum.GetLength(1));

            ParsePhaseMaskInput(xyDimNum, OAMNum, phaseIntensityNum, gratingWavelengthNum, maxIntensityNum);
            ParsePhaseMaskInput34(dimensionsSlm34, parameterASlm34, parameterBSlm34, wavelengthSlm34, frequencySlm34, amplitudeSlm34);
            //ParsePhaseMaskInput4(dimensionsSlm4, parameterASlm4, parameterBSlm4, wavelengthSlm4, frequencySlm4, alphaSlm4, amplitudeSlm4);
        
        
        }




        private double FindMinimumOf3DArray(double[,,] arrayInput, double lValue)
        {
            double minimum = arrayInput[0, 0, (int)lValue];
            for (int columns = 0; columns < arrayInput.GetLength(0); columns++)
            {
                for (int rows = 0; rows < arrayInput.GetLength(1); rows++)
                {
                    if (arrayInput[columns, rows, (int)lValue] < minimum)
                    {
                        minimum = arrayInput[columns, rows, (int)lValue];
                    }
                }
            }
            return minimum;
        }

        private double FindMaximumOf3DArray(double[,,] arrayInput, double lValue)
        {
            double maximum = arrayInput[0, 0, (int)lValue];
            for (int columns = 0; columns < arrayInput.GetLength(0); columns++)
            {
                for (int rows = 0; rows < arrayInput.GetLength(1); rows++)
                {
                    if (arrayInput[columns, rows,(int)lValue] > maximum)
                    {
                        maximum = arrayInput[columns, rows, (int)lValue];
                    }
                }
            }
            return maximum;
        }

        private double FindMinimumOf2DArray(double[,] arrayInput)
        {
            double minimum = arrayInput[0, 0];
            for (int columns = 0; columns < arrayInput.GetLength(0); columns++)
            {
                for (int rows = 0; rows < arrayInput.GetLength(1); rows++)
                {
                    if (arrayInput[columns, rows] < minimum)
                    {
                        minimum = arrayInput[columns, rows];
                    }
                }
            }
            return minimum;
        }
        private double FindMaximumOf2DArray(double[,] arrayInput)
        {
            double maximum = arrayInput[0, 0];
            for (int columns = 0; columns < arrayInput.GetLength(0); columns++)
            {
                for (int rows = 0; rows < arrayInput.GetLength(1); rows++)
                {
                    if (arrayInput[columns, rows] > maximum)
                    {
                        maximum = arrayInput[columns, rows];
                    }
                }
            }
            return maximum;
        }

        public Screen GetSecondaryScreen()
        {
            if (Screen.AllScreens.Length == 1)
            {
                return null;
            }

            foreach (Screen screen in Screen.AllScreens)
            {
                if (screen.Primary == false)
                {
                    return screen;
                }
            }

            return null;
        }


                //if multiple values are input for the fields, this feeds them to the CreatePhaseMask function one at a time
        private void ParsePhaseMaskInput(int[][] dimensions, double[][] lValue, double[][] alpha, double[][] wavelength, double[][] amplitude)
        {
            //iterates through all the comma separated segments
            for (int dimensionsNumber = 0; dimensionsNumber < dimensions.Length; dimensionsNumber++)
            {
                for (int lValueNumber = 0; lValueNumber < lValue.Length; lValueNumber++)
                {
                    for (int alphaNumber = 0; alphaNumber < alpha.Length; alphaNumber++)
                    {
                        for (int wavelengthNumber = 0; wavelengthNumber < wavelength.Length; wavelengthNumber++)
                        {
                            for (int amplitudeNumber = 0; amplitudeNumber < amplitude.Length; amplitudeNumber++)
                            {

                                //generate the full ranges for each colon-separated section
                                int[] dimensionsList = GenerateRangeInt(dimensions[dimensionsNumber]);
                                double[] lValueList = GenerateRangeDouble(lValue[lValueNumber]);
                                double[] alphaList = GenerateRangeDouble(alpha[alphaNumber]);
                                double[] wavelengthList = GenerateRangeDouble(wavelength[wavelengthNumber]);
                                double[] amplitudeList = GenerateRangeDouble(amplitude[amplitudeNumber]);

                                //iterates through all the colon separated segments
                                foreach (int dimensionsChoice in dimensionsList)
                                {
                                    foreach (double lValueChoice in lValueList)
                                    {
                                        currentOAM.Text = lValueChoice.ToString();
                                        foreach (double alphaChoice in alphaList)
                                        {
                                            currentPhaseIntensity.Text = alphaChoice.ToString();
                                            foreach (double wavelengthChoice in wavelengthList)
                                            {
                                                currentGratingWavelength.Text = wavelengthChoice.ToString();
                                                foreach (double amplitudeChoice in amplitudeList)
                                                {
                                                    currentMaxIntensity.Text = amplitudeChoice.ToString();
                                                    //generates a mask
                                                    CreatePhaseMask(dimensionsChoice, Convert.ToDouble(slm1oam.Text), alphaChoice, wavelengthChoice, amplitudeChoice); //slm1 only takes single values for now
                                                    CreatePhaseMask2(dimensionsChoice, lValueChoice, alphaChoice, wavelengthChoice, amplitudeChoice);

                                                    //performs a time delay for SLM to adjust
                                                    //PauseForMilliSeconds(5);


                                                    //stop recording .wav after delay time
                                                    
                                                    /**int samplingFrequency = 44000; //frequency that microphone port is sampled
                                                    int deviceNumber = 0; //port of microphone
                                                    string SLM = "SLM1";
                                                    string fileName = filenaming(dimensionsChoice, lValueChoice, alphaChoice, wavelengthChoice, amplitudeChoice, SLM);
                                                    startRecording(samplingFrequency, deviceNumber, fileName);

                                                    stopRecording();**/

                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }



        //if multiple values are input for the fields for SLM 3, 4
        private void ParsePhaseMaskInput34(int[][] dimensions, double[][] parameterD, double[][] parameterB, double[][] wavelength, double[][] f, double[][] amplitude)
        {
            //iterates through all the comma separated segments
            for (int dimensionsNumber = 0; dimensionsNumber < dimensions.Length; dimensionsNumber++)
            {
                for (int fNumber = 0; fNumber < f.Length; fNumber++)
                {
                    for (int wavelengthNumber = 0; wavelengthNumber < wavelength.Length; wavelengthNumber++)
                    {
                        for (int amplitudeNumber = 0; amplitudeNumber < amplitude.Length; amplitudeNumber++)
                        {
                            for (int parameterDNumber = 0; parameterDNumber < parameterD.Length; parameterDNumber++)
                            {
                                for (int parameterBNumber = 0; parameterBNumber < parameterB.Length; parameterBNumber++)
                                {

                                    //generate the full ranges for each colon-separated section
                                    int[] dimensionsList = GenerateRangeInt(dimensions[dimensionsNumber]);
                                    double[] fList = GenerateRangeDouble(f[fNumber]);
                                    double[] wavelengthList = GenerateRangeDouble(wavelength[wavelengthNumber]);
                                    double[] amplitudeList = GenerateRangeDouble(amplitude[amplitudeNumber]);
                                    double[] parameterDList = GenerateRangeDouble(parameterD[parameterDNumber]);
                                    double[] parameterBList = GenerateRangeDouble(parameterB[parameterBNumber]);

                                    //iterates through all the colon separated segments
                                    foreach (int dimensionsChoice in dimensionsList)
                                    {
                                        foreach (double fChoice in fList)
                                        {
                                            foreach (double wavelengthChoice in wavelengthList)
                                            {
                                                foreach (double amplitudeChoice in amplitudeList)
                                                {
                                                    foreach (double parameterDChoice in parameterDList)
                                                    {
                                                        foreach (double parameterBChoice in parameterBList)
                                                        {
                                                            //generates mask for SLM3
                                                            CreatePhaseMask34(dimensionsChoice, parameterDChoice, parameterBChoice, wavelengthChoice, fChoice, amplitudeChoice);

                                                            //performs a time delay
                                                            DateTime start = DateTime.Now;
                                                            while (DateTime.Now.Subtract(start).Seconds < 2)
                                                            {
                                                                Application.DoEvents();
                                                                System.Threading.Thread.Sleep(1);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
                
        private void CreatePhaseMask(int dimensions, double lValue, double alpha, double wavelength, double amplitude)
        {
            double[,] phaseVal = new double[dimensions, dimensions]; //becomes the transmission mask
            System.Drawing.Bitmap phaseMask = new System.Drawing.Bitmap(dimensions, dimensions); //necessary to display image of transmission mask
            double min;
            double tempdouble = 0;
            int tempint = 0;
            for (int columns = 0; columns < dimensions; columns++)
            {
                //System.Diagnostics.Debug.WriteLine(columns);
                for (int rows = 0; rows < dimensions; rows++)
                {
                    int xCenter = (int)Math.Round((float)dimensions / 2);
                    int yCenter = (int)Math.Round((float)dimensions / 2);
                    int xVal = 15 * (columns - xCenter); // converts to position in microns, taking the center as (0,0)  //maybe remove the 15
                    int yVal = 15 * (rows - yCenter); // converts to position in microns, taking the center as (0,0) //maybe remove the 15

                    //generates the phase component of the mask
                    //phaseVal[columns, rows] = lValue * (Math.PI+Math.Atan2(yVal, xVal)) - 2 * Math.PI * xVal / wavelength; // (l*phi - k*x)/2, phase component
                    phaseVal[columns, rows] = lValue * (Math.PI + Math.Atan2(yVal, xVal)) - 2 * Math.PI * xVal / wavelength;
                    if (blazingToggle.Checked == true) 
                    { 
                        phaseVal[columns, rows] = phaseVal[columns, rows] % (2 * Math.PI); 
                    } //apply mod 2pi blazing if blazingToggle is checked

                    //generate transmission mask element in units of gray level. Amplitude input term is in radians.
                    phaseVal[columns,rows] = Math.Round((65536-1) / (2 * Math.PI) * amplitude * Math.Cos(alpha * phaseVal[columns, rows])); //divided 256^2 by 2 and subt by 1 to use only pi of the SLM phase
                }
            }

            min = FindMinimumOf2DArray(phaseVal);
            double max = FindMaximumOf2DArray(phaseVal)+Math.Abs(min);
            double halfMax = max/2;
            //System.Diagnostics.Debug.WriteLine(max);

            //elevating values of phase mask to be >= 0, and applying calibration
            for (int columns = 0; columns < dimensions; columns++)
            {
                for (int rows = 0; rows < dimensions; rows++)
                {
                    if (calibrationCheck.Checked == true)
                    {
                        tempdouble = phaseVal[columns, rows] + Math.Abs(min);
                        tempdouble = tempdouble % (65536 - 1);// 65535;
                        tempint = Convert.ToInt32(Math.Floor(tempdouble));
                        if (SquareBlazing.Checked == true)
                        {
                            if (tempint < halfMax)
                            {
                                tempint = 0;
                            }
                            else
                            {
                                tempint = Convert.ToInt32(Math.Floor(max));
                            }
                        }
                        phaseVal[columns, rows] = calibration1[tempint];
                    }
                    else
                    {
                        phaseVal[columns, rows] = phaseVal[columns, rows] + Math.Abs(min); //make the mask all positive or 0
                        phaseVal[columns, rows] = phaseVal[columns, rows] % 65535;// take mod of the mask amplitude by the SLM throw of 2^16
                        if (SquareBlazing.Checked == true)
                        {
                            if (phaseVal[columns, rows] < halfMax)
                            {
                                phaseVal[columns,rows] = 0;
                            }
                            else
                            {
                                phaseVal[columns, rows] = max;
                            }
                        }
                    }
                }
            }

            //set the pixel color, encoding gray level for that location on the mask
            for (int columns = 0; columns < dimensions; columns++)
            {
                for (int rows = 0; rows < dimensions; rows++)
                {
                    Color color = Color.FromArgb((int)phaseVal[columns, rows] % 256, ((int)phaseVal[columns, rows] - ((int)phaseVal[columns, rows] % 256)) / 256, 0);//red, green, blue
                    phaseMask.SetPixel(columns, rows, color);
                }
            }
            imageBox1.Image = (Image)phaseMask;

            closePhaseMasks(1);

            Form form = new Form();

            Form form1 = new Form();

            PictureBox pictureBox = new PictureBox();
            pictureBox.Image = (Image)phaseMask;

            PictureBox pictureBox1 = new PictureBox();
            pictureBox1.Image = (Image)phaseMask;

            form.StartPosition = FormStartPosition.CenterScreen;
            form.Size = phaseMask.Size;
            form.FormBorderStyle = FormBorderStyle.None;
            form.StartPosition = FormStartPosition.Manual;

            form1.StartPosition = FormStartPosition.CenterScreen;
            form1.Size = phaseMask.Size;
            form1.FormBorderStyle = FormBorderStyle.None;
            form1.StartPosition = FormStartPosition.Manual;

            Screen[] sc;
            sc = Screen.AllScreens;

            // Get SLM 1
            Screen screen = sc[0]; //sc[0] is SLM 1, sc[1] is SLM 2, sc[2] is SLM 4, sc[3] is monitor, sc[4] is SLM 3

            //set the location to the top left of the second screen
            form.Location = screen.WorkingArea.Location;

            // set it fullscreen
            form.Size = new Size(screen.WorkingArea.Width, screen.WorkingArea.Height);

            pictureBox.Dock = DockStyle.Fill;

            form.Controls.Add(pictureBox);
            form.Show();

        }


        private void CreatePhaseMask2(int dimensions, double lValue, double alpha, double wavelength, double amplitude) //double innerRadius, double outerRadius)
        {
            double[,] phaseVal = new double[dimensions, dimensions]; //becomes the transmission mask
            System.Drawing.Bitmap phaseMask = new System.Drawing.Bitmap(dimensions, dimensions); //necessary to display image of transmission mask
            double min;
            double tempdouble = 0;
            int tempint = 0;
            for (int columns = 0; columns < dimensions; columns++)
            {
                //System.Diagnostics.Debug.WriteLine(columns);
                for (int rows = 0; rows < dimensions; rows++)
                {
                    int xCenter = (int)Math.Round((float)dimensions / 2);
                    int yCenter = (int)Math.Round((float)dimensions / 2);
                    int xVal = 15 * (columns - xCenter); // converts to position in microns, taking the center as (0,0)  //maybe remove the 15
                    int yVal = 15 * (rows - yCenter); // converts to position in microns, taking the center as (0,0) //maybe remove the 15
                    
                    double innerRadius = 50 * 15; //100 pixels * 15 microns per pixel
                    double outerRadius = 25*15; //512 pixels * 15 microns per pixel

                    if (outerRadius == 0)//disable outer truncation if outerRadius is set to 0
                    {
                        outerRadius = 512 * 15;
                    }

                    if (Math.Sqrt(Math.Pow(xVal, 2) + Math.Pow(yVal, 2)) > innerRadius && (Math.Sqrt(Math.Pow(xVal, 2) + Math.Pow(yVal, 2)) < outerRadius))
                    {
                        //generates the phase component of the mask
                        //phaseVal[columns, rows] = lValue * (Math.PI+Math.Atan2(yVal, xVal)) - 2 * Math.PI * xVal / wavelength; // (l*phi - k*x)/2, phase component
                        phaseVal[columns, rows] = lValue * (Math.PI + Math.Atan2(yVal, xVal)) - 2 * Math.PI * xVal / wavelength;
                    }
                    else
                    {
                        phaseVal[columns, rows] = 0; //inputs 0 as a double
                    }

                    //generates the phase component of the mask
                    //phaseVal[columns, rows] = lValue * (Math.PI+Math.Atan2(yVal, xVal)) - 2 * Math.PI * xVal / wavelength; // (l*phi - k*x)/2, phase component
                    //phaseVal[columns, rows] = lValue * (Math.PI + Math.Atan2(yVal, xVal)) - 2 * Math.PI * xVal / wavelength;
                    if (blazingToggle.Checked == true)
                    {
                        phaseVal[columns, rows] = phaseVal[columns, rows] % (2 * Math.PI);
                    } //apply mod 2pi blazing if blazingToggle is checked

                    //generate transmission mask element in units of gray level. Amplitude input term is in radians.
                    phaseVal[columns, rows] = Math.Round((65536 - 1) / (2 * Math.PI) * amplitude * Math.Cos(alpha * phaseVal[columns, rows])); //divided 256^2 by 2 and subt by 1 to use only pi of the SLM phase
                }
            }

            min = FindMinimumOf2DArray(phaseVal);
            double max = FindMaximumOf2DArray(phaseVal) + Math.Abs(min);
            double halfMax = max / 2;
            //System.Diagnostics.Debug.WriteLine(max);

            //elevating values of phase mask to be >= 0, and applying calibration
            for (int columns = 0; columns < dimensions; columns++)
            {
                for (int rows = 0; rows < dimensions; rows++)
                {
                    phaseVal[columns, rows] = phaseVal[columns, rows] + Math.Abs(min);
                    phaseVal[columns, rows] = phaseVal[columns, rows] % 65535;// take mod of the mask amplitude by the SLM throw of 2^16
                        
        

                    if (calibrationCheck.Checked == true)
                    {
                        tempdouble = phaseVal[columns, rows] + Math.Abs(min);
                        tempdouble = tempdouble % (65536  - 1);// 65535;
                        tempint = Convert.ToInt32(Math.Floor(tempdouble));
                        if (SquareBlazing.Checked == true)
                        {
                            if (tempint < halfMax)
                            {
                                tempint = 0;
                            }
                            else
                            {
                                tempint = Convert.ToInt32(Math.Floor(max));
                            }
                        }
                        phaseVal[columns, rows] = calibration1[tempint];
                    }
                    else
                    {
                        phaseVal[columns, rows] = phaseVal[columns, rows] + Math.Abs(min); //make the mask all positive or 0
                        phaseVal[columns, rows] = phaseVal[columns, rows] % 65535;// take mod of the mask amplitude by the SLM throw of 2^16
                        if (SquareBlazing.Checked == true)
                        {
                            if (phaseVal[columns, rows] < halfMax)
                            {
                                phaseVal[columns, rows] = 0;
                            }
                            else
                            {
                                phaseVal[columns, rows] = max;
                            }
                        }
                    }

                    int xCenter = (int)Math.Round((float)dimensions / 2);
                    int yCenter = (int)Math.Round((float)dimensions / 2);
                    int xVal = 15 * (columns - xCenter); // converts to position in microns, taking the center as (0,0)  //maybe remove the 15
                    int yVal = 15 * (rows - yCenter); // converts to position in microns, taking the center as (0,0) //maybe remove the 15

                    double innerRadius = 50 * 15; //100 pixels * 15 microns per pixel
                    double outerRadius = 256 * 15; //512 pixels * 15 microns per pixel

                    if (outerRadius == 0)//disable outer truncation if outerRadius is set to 0
                    {
                        outerRadius = 512 * 15;
                    }

                    if (!(Math.Sqrt(Math.Pow(xVal, 2) + Math.Pow(yVal, 2)) > innerRadius && (Math.Sqrt(Math.Pow(xVal, 2) + Math.Pow(yVal, 2)) < outerRadius)))
                    {
                        phaseVal[columns, rows] = 0;
                    }


                }

                
            }

            //normalization?

            //set the pixel color, encoding gray level for that location on the mask
            for (int columns = 0; columns < dimensions; columns++)
            {
                for (int rows = 0; rows < dimensions; rows++)
                {
                    Color color = Color.FromArgb((int)phaseVal[columns, rows] % 256, ((int)phaseVal[columns, rows] - ((int)phaseVal[columns, rows] % 256)) / 256, 0);//red, green, blue
                    phaseMask.SetPixel(columns, rows, color);
                }
            }
            imageBox1.Image = (Image)phaseMask;

            closePhaseMasks(2);

            Form form = new Form();

            PictureBox pictureBox = new PictureBox();
            pictureBox.Image = (Image)phaseMask;

            form.StartPosition = FormStartPosition.CenterScreen;
            form.Size = phaseMask.Size;
            form.FormBorderStyle = FormBorderStyle.None;
            form.StartPosition = FormStartPosition.Manual;

            Screen[] sc;
            sc = Screen.AllScreens;

            // Get SLM 2
            Screen screen = sc[0];//screen changed

            // set the location to the top left of the second screen
            form.Location = screen.WorkingArea.Location;

            // set it fullscreen
            form.Size = new Size(screen.WorkingArea.Width, screen.WorkingArea.Height);

            pictureBox.Dock = DockStyle.Fill;

            form.Controls.Add(pictureBox);
            form.Show();
            //}

        }

        private void squareBlazing(int tempint, double max)
        {
            double halfMax = max / 2;
            if (tempint < halfMax)
            {
                tempint = 0;
            }
            else
            {
                tempint = Convert.ToInt32(Math.Floor(max));
            }
        }

        private void CreatePhaseMask2Superposition(int dimensions, double[] lValues, double alpha, double wavelength, double amplitude) //double innerRadius, double outerRadius)
        {
            double[,,] phaseVal = new double[dimensions, dimensions, lValues.Length]; //becomes the overall transmission mask
            double tempdouble = 0;
            int tempint = 0;
            System.Drawing.Bitmap phaseMask = new System.Drawing.Bitmap(dimensions, dimensions); //necessary to display image of transmission mask
            
            int lValueNumber = 0;



            for (; lValueNumber < lValues.Length+1; lValueNumber++)//iterates across all lValues to obtain superposition of transition masks for each lValue
                {
                double lValue = lValues[lValueNumber];
                double min = FindMinimumOf3DArray(phaseVal, lValueNumber);
                double maxCurrent = FindMaximumOf3DArray(phaseVal, lValueNumber);

                double halfMax = maxCurrent / 2; 

                for (int columns = 0; columns < dimensions; columns++)
                {
                for (int rows = 0; rows < dimensions; rows++)
                {
                    int xCenter = (int)Math.Round((float)dimensions / 2);
                    int yCenter = (int)Math.Round((float)dimensions / 2);
                    int xVal = 15 * (columns - xCenter); // converts to position in microns, taking the center as (0,0)  //maybe remove the 15
                    int yVal = 15 * (rows - yCenter); // converts to position in microns, taking the center as (0,0) //maybe remove the 15

                
                    //generates the phase component of the mask
                    phaseVal[columns, rows,lValueNumber] = lValue * (Math.PI + Math.Atan2(yVal, xVal)) - 2 * Math.PI * xVal / wavelength; // (l*phi - k*x)/2, phase component
                    

                    if (blazingToggle.Checked == true)
                    {
                        phaseVal[columns, rows, lValueNumber] = phaseVal[columns, rows, lValueNumber] % (2 * Math.PI);
                        
                    } //apply mod 2pi blazing if blazingToggle is checked
                       
                    //generate transmission mask element in units of gray level. Amplitude input term is in radians.
                    phaseVal[columns, rows, lValueNumber] = Math.Round((65536 - 1) / (2 * Math.PI) * amplitude * Math.Cos(alpha * phaseVal[columns, rows, lValueNumber])); //divided 256^2 by 2 and subt by 1 to use only pi of the SLM phase

                    

                    phaseVal[columns, rows, lValueNumber] = phaseVal[columns, rows, lValueNumber] + Math.Abs(min);
                    phaseVal[columns, rows, lValueNumber] = phaseVal[columns, rows, lValueNumber] % 65535;// take mod of the mask amplitude by the SLM throw of 2^16

                    if (calibrationCheck.Checked == true)
                    {
                        tempdouble = phaseVal[columns, rows, lValueNumber] + Math.Abs(min);
                        tempdouble = tempdouble % (65536 - 1);// 65535;
                        tempint = Convert.ToInt32(Math.Floor(tempdouble));
                        if (SquareBlazing.Checked == true)
                        {
                            if (tempint < halfMax)
                            {
                                tempint = 0;
                            }
                            else
                            {
                                tempint = Convert.ToInt32(Math.Floor(maxCurrent));
                            }
                        }
                        phaseVal[columns, rows, lValueNumber] = calibration1[tempint];
                    }
                    else
                    {
                        phaseVal[columns, rows, lValueNumber] = phaseVal[columns, rows, lValueNumber] + Math.Abs(min); //make the mask all positive or 0
                        phaseVal[columns, rows, lValueNumber] = phaseVal[columns, rows, lValueNumber] % 65535;// take mod of the mask amplitude by the SLM throw of 2^16
                        if (SquareBlazing.Checked == true)
                        {
                            if (phaseVal[columns, rows, lValueNumber] < halfMax)
                            {
                                phaseVal[columns, rows, lValueNumber] = 0;
                            }
                            else
                            {
                                phaseVal[columns, rows, lValueNumber] = maxCurrent;
                            }
                        }
                    }

                    double innerRadius = 50 * 15; //100 pixels * 15 microns per pixel
                    double outerRadius = 256 * 15; //512 pixels * 15 microns per pixel

                    if (outerRadius == 0)//disable outer truncation if outerRadius is set to 0
                    {
                        outerRadius = 512 * 15;
                    }

                    if (!(Math.Sqrt(Math.Pow(xVal, 2) + Math.Pow(yVal, 2)) > innerRadius && (Math.Sqrt(Math.Pow(xVal, 2) + Math.Pow(yVal, 2)) < outerRadius)))
                    {
                        phaseVal[columns, rows, lValueNumber] = 0;
                    }

                    if (lValueNumber > 0)//only do superpositioning if there is another transmission mask
                    {
                        double maxPrevious = FindMaximumOf3DArray(phaseVal, lValueNumber - 1);
                    phaseVal[columns, rows, lValueNumber] = phaseVal[columns, rows, lValueNumber] * phaseVal[columns, rows, lValueNumber - 1];//superposition of 
                    phaseVal[columns, rows, lValueNumber] = phaseVal[columns, rows, lValueNumber] * 65535 / (maxCurrent * maxPrevious); //normalization
                    }
                    
                    
                }
                
            }
       
                
             }
            int maxlValue = lValues.Length - 1;
   
            //set the pixel color, encoding gray level for that location on the mask
            for (int columns = 0; columns < dimensions; columns++)
            {
                for (int rows = 0; rows < dimensions; rows++)
                {
                    Color color = Color.FromArgb((int)phaseVal[columns, rows, lValueNumber] % 256, ((int)phaseVal[columns, rows, maxlValue] - ((int)phaseVal[columns, rows, lValueNumber] % 256)) / 256, 0);//red, green, blue
                    phaseMask.SetPixel(columns, rows, color);
  
                }
            }
            imageBox1.Image = (Image)phaseMask;

            //closePhaseMasks(2);

            Form form = new Form();

            PictureBox pictureBox = new PictureBox();
            pictureBox.Image = (Image)phaseMask;

            form.StartPosition = FormStartPosition.CenterScreen;
            form.Size = phaseMask.Size;
            form.FormBorderStyle = FormBorderStyle.None;
            form.StartPosition = FormStartPosition.Manual;

            Screen[] sc;
            sc = Screen.AllScreens;

            // Get SLM 2
            Screen screen = sc[0];//screen changed

            // set the location to the top left of the second screen
            form.Location = screen.WorkingArea.Location;

            // set it fullscreen
            form.Size = new Size(screen.WorkingArea.Width, screen.WorkingArea.Height);

            pictureBox.Dock = DockStyle.Fill;

            form.Controls.Add(pictureBox);
            form.Show();
            //}

        }
   
        private void CreatePhaseMask34(int dimensions, double parameterD, double parameterB, double wavelength, double f, double amplitude) //PhaseMask for SLM 3
        {
            double[,] phaseVal3 = new double[dimensions, dimensions]; //becomes the transmission mask
            double[,] phaseVal4 = new double[dimensions, dimensions];
            System.Drawing.Bitmap phaseMask3 = new System.Drawing.Bitmap(dimensions, dimensions); //necessary to display image of transmission mask
            System.Drawing.Bitmap phaseMask4 = new System.Drawing.Bitmap(dimensions, dimensions);
            double min3, min4;
            double tempdouble3 = 0;
            int tempint3 = 0;
            double tempdouble4 = 0;
            int tempint4 = 0;
            int xCenter = (int)Math.Round((float)dimensions / 2);
            int yCenter = (int)Math.Round((float)dimensions / 2);

            for (int columns = 0; columns < dimensions; columns++)
            {
                for (int rows = 0; rows < dimensions; rows++)
                {
                    int xVal = 15 * (columns - xCenter); // converts to position in microns, taking the center as (0,0)  //maybe remove the 15
                    int yVal = 15 * (rows - yCenter); // converts to position in microns, taking the center as (0,0) //maybe remove the 15
                    //generates the phase component of the mask
                    if ((xVal * xVal) + (yVal * yVal) == 0)
                    {
                        phaseVal3[rows, columns] = 0;
                    }
                    else
                    {
                        phaseVal3[rows, columns] = parameterD  / (wavelength * f) * (yVal * Math.Atan2(yVal, xVal) - xVal * Math.Log(Math.Sqrt((xVal * xVal) + (yVal * yVal)) / parameterB) + xVal); //apply phi1 function
                    }
                    phaseVal4[rows, columns] = parameterD * parameterB / (wavelength * f) * Math.Exp(-xVal * 2 * Math.PI / parameterD) * Math.Cos(yVal / (parameterD / (2 * Math.PI))); // phi2 function
                    
                    //generate transmission mask element in units of gray level. Amplitude input term is in radians.
                    //phaseVal3[columns, rows] = Math.Round(65535 / (2 * Math.PI) * amplitude * Math.Cos( phaseVal3[columns, rows]));
                    phaseVal3[rows, columns] = Math.Round(65535 / (2 * Math.PI) * amplitude * phaseVal3[rows, columns]);
                    phaseVal4[rows, columns] = Math.Round(65535 / (2 * Math.PI) * amplitude * phaseVal4[rows, columns]);
                    //System.Diagnostics.Debug.WriteLine(phaseVal[columns, rows]);
                }
            }
            min3 = FindMinimumOf2DArray(phaseVal3);
            min4 = FindMinimumOf2DArray(phaseVal4);

            for (int columns = 0; columns < dimensions; columns++)
            {
                for (int rows = 0; rows < dimensions; rows++)
                {
                    if (calibrationCheck.Checked == true)
                    {
                        tempdouble3 = phaseVal3[columns, rows] + Math.Abs(min3);
                        tempdouble3 = tempdouble3 % ((65536  - 1));// 65535;
                        tempint3 = Convert.ToInt32(Math.Floor(tempdouble3));
                        phaseVal3[columns, rows] = calibration3[tempint3];
                        tempdouble4 = phaseVal4[columns, rows] + Math.Abs(min4);
                        tempdouble4 = tempdouble4 % ((65536  - 1));// 65535;
                        tempint4 = Convert.ToInt32(Math.Floor(tempdouble4));
                        phaseVal4[columns, rows] = calibration4[tempint4];
                    }
                    else
                    {
                        phaseVal3[columns, rows] = phaseVal3[columns, rows] + Math.Abs(min3); //make the mask all positive or 0
                        phaseVal3[columns, rows] = phaseVal3[columns, rows] % 65535; // take mod of the mask amplitude by the SLM throw of 2^16
                        phaseVal4[columns, rows] = phaseVal4[columns, rows] + Math.Abs(min4); //make the mask all positive or 0
                        phaseVal4[columns, rows] = phaseVal4[columns, rows] % 65535; // take mod of the mask amplitude by the SLM throw of 2^16
                    }
                }
            }

            //set the pixel color, encoding gray level for that location on the mask
            for (int columns = 0; columns < dimensions; columns++)
            {
                for (int rows = 0; rows < dimensions; rows++)
                {
                    //System.Diagnostics.Debug.WriteLine(phaseVal[columns, rows]);
                    Color color3 = Color.FromArgb((int)Math.Floor(phaseVal3[columns, rows] % 256), ((int)Math.Floor(phaseVal3[columns, rows]) - ((int)Math.Floor(phaseVal3[columns, rows]) % 256)) / 256, 0);//red, green, blue
                    phaseMask3.SetPixel(columns, rows, color3);
                }
            }

            for (int columns = 0; columns < dimensions; columns++)
            {
                for (int rows = 0; rows < dimensions; rows++)
                {
                    Color color4 = Color.FromArgb((int)phaseVal4[columns, rows] % 256, ((int)phaseVal4[columns, rows] - (int)phaseVal4[columns, rows] % 256) / 256, 0);//red, green, blue
                    phaseMask4.SetPixel(columns, rows, color4);
                }
            }

            //SLM 3 Image processing
            imageBox3.Image = (Image)phaseMask3;

            closePhaseMasks(3);

            Form form3 = new Form();

            PictureBox pictureBox3 = new PictureBox();
            pictureBox3.Image = (Image)phaseMask3;

            form3.StartPosition = FormStartPosition.CenterScreen;
            form3.Size = phaseMask3.Size;
            form3.FormBorderStyle = FormBorderStyle.None;
            form3.StartPosition = FormStartPosition.Manual;

            Screen[] sc;
            sc = Screen.AllScreens;

            // Screen = SLM 3
            Screen screen3 = sc[0];//screen changed

            // set the location to the top left of the second screen
            form3.Location = screen3.WorkingArea.Location;

            // set it fullscreen
            form3.Size = new Size(screen3.WorkingArea.Width, screen3.WorkingArea.Height);

            pictureBox3.Dock = DockStyle.Fill;

            form3.Controls.Add(pictureBox3);
            form3.Show();

            //SLM 4 Image processing
            imageBox4.Image = (Image)phaseMask4;

            closePhaseMasks(4);

            Form form4 = new Form();

            PictureBox pictureBox4 = new PictureBox();
            pictureBox4.Image = (Image)phaseMask4;

            form4.StartPosition = FormStartPosition.CenterScreen;
            form4.Size = phaseMask4.Size;
            form4.FormBorderStyle = FormBorderStyle.None;
            form4.StartPosition = FormStartPosition.Manual;


            // Screen = SLM 4
            Screen screen4 = sc[0];

            // set the location to the top left of the second screen
            form4.Location = screen4.WorkingArea.Location;

            // set it fullscreen
            form4.Size = new Size(screen4.WorkingArea.Width, screen4.WorkingArea.Height);

            pictureBox4.Dock = DockStyle.Fill;

            form4.Controls.Add(pictureBox4);
            form4.Show();
             
        }


        //accepts start:step:end or single value arrays and generates a corresponding linear array
        private int[] GenerateRangeInt(int[] input)
        {
            //for single values, just return the input value
            if (input.Length == 1)
            {
                return input;
            }

            //for triple arrays, create an array of appropriate step size
            if (input.Length == 3)
            {
                int arrayLength = (int)Math.Floor(((float)input[2] - (float)input[0]) / (float)input[1]);
                int[] dataArray = new int[arrayLength];
                int value = input[0];
                int count = 0;

                while (value <= Math.Abs(input[2]))
                {
                    dataArray[count] = value;
                    count++;
                    value += input[1];
                }

                return dataArray;
            }
            return null;
        }

        //accepts start:step:end or single value arrays and generates a corresponding linear array
        private double[] GenerateRangeDouble(double[] input)
        {
            //for single values, just return the input value
            if (input.Length == 1)
            {
                return input;
            }

            //for triple arrays, create an array of appropriate step size
            if (input.Length == 3)
            {
                int arrayLength = (int)Math.Floor((input[2] - input[0]) / input[1]) + 1;
                double[] dataArray = new double[arrayLength];

                for (int i = 0; i < dataArray.Length; i++)
                {
                    dataArray[i] = input[0] + i * input[1];
                }

                return dataArray;
            }

            return null;
        }


        // takes data of format "111:2:333,31:15:15" and parses by commas, then by colons.
        private int[][] ParseScanSequenceInt(string input)
        {
            //first parse by commas
            string pattern = @",";
            string[] commaParsed = Regex.Split(input, pattern);

            //then fill a staggered array and parse by colons
            pattern = @":";
            string[][] result = new string[commaParsed.Length][];

            for (int i = 0; i < commaParsed.Length; i++)
            {
                string[] resultLine = Regex.Split(commaParsed[i], pattern);
                result[i] = new string[resultLine.Length];

                for (int j = 0; j < resultLine.Length; j++)
                {
                    result[i][j] = resultLine[j];
                }
            }

            //then Parse from string to numbers
            int[][] output = new int[result.Length][];

            for (int i = 0; i < result.Length; i++)
            {
                output[i] = new int[result[i].Length];

                for (int j = 0; j < result[i].Length; j++)
                {
                    output[i][j] = int.Parse(result[i][j]);
                }
            }

            //return the numbers
            return output;
        }

        // takes data of format "111:2:333,31:15:15" and parses by commas, then by colons.
        private double[][] ParseScanSequenceDouble(string input)
        {
            //first parse by commas
            string pattern = @",";
            string[] commaParsed = Regex.Split(input, pattern);

            //then fill a staggered array and parse by colons
            pattern = @":";
            string[][] result = new string[commaParsed.Length][];

            for (int i = 0; i < commaParsed.Length; i++)
            {
                string[] resultLine = Regex.Split(commaParsed[i], pattern);
                result[i] = new string[resultLine.Length];

                for (int j = 0; j < resultLine.Length; j++)
                {
                    result[i][j] = resultLine[j];
                }
            }

            //then Parse from string to numbers
            double[][] output = new double[result.Length][];

            for (int i = 0; i < result.Length; i++)
            {
                output[i] = new double[result[i].Length];

                for (int j = 0; j < result[i].Length; j++)
                {
                    output[i][j] = double.Parse(result[i][j]);
                }
            }

            //return the numbers
            return output;
        }


        private void button1_Click(object sender, EventArgs e)
        {
            double[, , , ,] testData = new double[1, 2, 3, 4, 5];
            System.Diagnostics.Debug.WriteLine(testData.GetLength(0));
            System.Diagnostics.Debug.WriteLine(testData.GetLength(1));
            System.Diagnostics.Debug.WriteLine(testData.GetLength(2));
            System.Diagnostics.Debug.WriteLine(testData.GetLength(3));
            System.Diagnostics.Debug.WriteLine(testData.GetLength(4));
            for (int i = 0; i < testData.GetLength(0); i++)
            {
                for (int j = 0; j < testData.GetLength(1); j++)
                {
                    for (int k = 0; k < testData.GetLength(2); k++)
                    {
                        for (int l = 0; l < testData.GetLength(3); l++)
                        {
                            for (int m = 0; m < testData.GetLength(4); m++)
                            {
                                /*testData[i,j,k,l,m] = 1;*/
                            }
                        }
                    }
                }
            }
            SaveData(testData);
            /**string test = "111:2:333:22,5,1:2:3,4";
            int[][] data = ParseScanSequenceInt(test);
            for (int i = 0; i < data.Length; i++)
            {
                for (int j = 0; j < data[i].Length; j++)
                {
                    System.Diagnostics.Debug.WriteLine(data[i][j]); 
                }
            }**/
        }

        private static void SaveData(double[, , , ,] saveFile)
        {
            string fileName = @"C:\Users\Polina\Documents\twisted light\Power Meter Data Sets\Power Meter Data " + DateTime.Now.ToString("MM\\.dd\\.yyyy h\\.mm tt") + ".txt";
            string val1 = @"C:\Users\Polina\Documents\twisted light\Power Meter Data Sets\Power Meter Data ";
            string val2 = DateTime.Now.ToString("MM\\.dd\\.yyyy h\\.mm tt");
            string val3 = ".txt";
            string fileName1 = string.Format("{0}{1}{2}", val1, val2, val3);
            int d0 = saveFile.GetLength(0);
            int d1 = saveFile.GetLength(1);
            int d2 = saveFile.GetLength(2);
            int d3 = saveFile.GetLength(3);
            int d4 = saveFile.GetLength(4);
            System.Diagnostics.Debug.WriteLine(fileName);
            using (StreamWriter writer = new StreamWriter(fileName1))
            {
                writer.WriteLine(Convert.ToString(d0));
                writer.WriteLine(Convert.ToString(d1));
                writer.WriteLine(Convert.ToString(d2));
                writer.WriteLine(Convert.ToString(d3));
                writer.WriteLine(Convert.ToString(d4));

                for (int i = 0; i < d0; i++)
                {
                    for (int j = 0; j < d1; j++)
                    {
                        for (int k = 0; k < d2; k++)
                        {
                            for (int l = 0; l < d3; l++)
                            {
                                for (int m = 0; m < d4; m++)
                                {
                                    System.Diagnostics.Debug.WriteLine(m);
                                    writer.WriteLine(Convert.ToString(saveFile[i, j, k, l, m]));
                                }
                            }
                        }
                    }
                }
            }
            System.Diagnostics.Debug.WriteLine(d0);
            System.Diagnostics.Debug.WriteLine(d1);
            System.Diagnostics.Debug.WriteLine(d2);
            System.Diagnostics.Debug.WriteLine(d3);
            System.Diagnostics.Debug.WriteLine(d4);
        }

private void closePhaseMasks(int j)
{
for (int i = Application.OpenForms.Count - 1; i >= j; i--)
            {
                if (Application.OpenForms[i].Name != "Menu")
                    Application.OpenForms[i].Close();
            }
}

        private void button2_Click(object sender, EventArgs e)
        {
            //double[] testRange = new double[3];
            //testRange[0] = 1.0;
            //testRange[1] = 0.1;
            //testRange[2] = 1.5;
            //double[] testRangeTwo = GenerateRangeDouble(testRange);
            //for (int i = 0; i < testRangeTwo.Length; i++)
            //{
            //    System.Diagnostics.Debug.WriteLine(testRangeTwo[i]);
            //}
            //CreatePhaseMask3(512, 1000000, 1, 0.0000005, 50000, 1, 1);
            //CreatePhaseMask4(512,512,512,512,512,512,512,512,512);
            //argument CreatePhaseMask3 (int dimensions, double parameterA, double parameterB, double wavelength, double frequency, double alpha, double amplitude)
            //argument CreatePhaseMask4 (int dimensions, double parameterA, double parameterB, double parameterU, double parameterV, double wavelength, double frequency, double alpha, double amplitude)
            //int dimensions, double lValue, double lValue2, double alpha, double wavelength, double amplitude) //double innerRadius, double outerRadius
            double[] lValues = new double[4]{1,2,3,4};
            CreatePhaseMask2Superposition(512,lValues,2,300,1.57);
        }

        /**
        // The below functions are responsible for determining the efficiency of a given phasemask. -JM
        private void button5_Click(object sender, EventArgs e)
        {

            //load and process .wav files from given path
            string path = "C:\\Users\\Polina\\Desktop\\wavFiles\\";
            ProcessDirectory(path);
            Console.WriteLine("Running");

            if (File.Exists(path))
            {
                // This path is a file
                ProcessFile(path);
            }
            else if (Directory.Exists(path))
            {
                // This path is a directory
                ProcessDirectory(path);
            }
            else
            {
                Console.WriteLine("{0} is not a valid file or directory.", path);

            }
        }

        NAudio.Wave.WaveIn sourceStream = null;
        NAudio.Wave.DirectSoundOut waveOut = null;
        NAudio.Wave.WaveFileWriter waveWriter = null;

        private void sourceStream_DataAvailable(object sender, NAudio.Wave.WaveInEventArgs e)
        {
            if (waveWriter == null) return;
            waveWriter.WriteData(e.Buffer, 0, e.BytesRecorded);
            waveWriter.Flush();
        }

        public void startRecording(int samplingFrequency, int deviceNumber, string fileName)
        {
            //SaveFileDialog save = new SaveFileDialog();
            //save.Filter = "Wave File (*.wav)|*.wav;";
            //if (save.ShowDialog() != System.Windows.Forms.DialogResult.OK) return;


            sourceStream = new NAudio.Wave.WaveIn();
            sourceStream.DeviceNumber = deviceNumber;
            sourceStream.WaveFormat = new NAudio.Wave.WaveFormat(samplingFrequency, NAudio.Wave.WaveIn.GetCapabilities(deviceNumber).Channels);

            sourceStream.DataAvailable += new EventHandler<NAudio.Wave.WaveInEventArgs>(sourceStream_DataAvailable);
            waveWriter = new NAudio.Wave.WaveFileWriter(fileName, sourceStream.WaveFormat);

            sourceStream.StartRecording();
            System.Diagnostics.Debug.WriteLine("Recording started.", fileName);
        }

        public void stopRecording()
        {
            PauseForMilliSeconds(500);
            if (waveOut != null)
            {
                waveOut.Stop();
                waveOut.Dispose();
                waveOut = null;
            }
            if (sourceStream != null)
            {
                sourceStream.StopRecording();
                sourceStream.Dispose();
                sourceStream = null;
            }
            if (waveWriter != null)
            {
                waveWriter.Dispose();
                waveWriter = null;
            }
            System.Diagnostics.Debug.WriteLine("Recording stopped.");
        }

        public void ProcessDirectory(string targetDirectory)
        {
            // Process the list of files found in the directory.
            string[] fileEntries = Directory.GetFiles(targetDirectory);
            foreach (string fileName in fileEntries)
                ProcessFile(fileName);

            // Recurse into subdirectories of this directory.
            string[] subdirectoryEntries = Directory.GetDirectories(targetDirectory);
            foreach (string subdirectory in subdirectoryEntries)
                ProcessDirectory(subdirectory);
        }

        public void ProcessFile(string path)
        {
            double[] left;
            double[] right;

            openWav(path, out left, out right);
            double aveLeft = average(left);
            double aveRight = average(right);
            System.Diagnostics.Debug.WriteLine(aveLeft);
            System.Diagnostics.Debug.WriteLine(aveRight);

            System.Diagnostics.Debug.WriteLine("Processed file.", path);
        }

        static double bytesToDouble(byte firstByte, byte secondByte)
        {
            // convert two bytes to one short (little endian)
            var s = (short)(firstByte << 8 | secondByte);
            //short s = (secondByte << 8) | firstByte;
            // convert to range from -1 to (just below) 1
            return s / 32768.0;
        }

        //Needs to be checked!
        // Returns left and right double arrays. 'right' will be null if sound is mono.
        public void openWav(string filename, out double[] left, out double[] right)
        {
            byte[] wav = File.ReadAllBytes(filename);

            // Determine if mono or stereo
            int channels = wav[22];     // Forget byte 23 as 99.999% of WAVs are 1 or 2 channels

            // Get past all the other sub chunks to get to the data subchunk:
            int pos = 12;   // First Subchunk ID from 12 to 16

            // Keep iterating until we find the data chunk (i.e. 64 61 74 61 ...... (i.e. 100 97 116 97 in decimal))
            while (!(wav[pos] == 100 && wav[pos + 1] == 97 && wav[pos + 2] == 116 && wav[pos + 3] == 97))
            {
                pos += 4;
                int chunkSize = wav[pos] + wav[pos + 1] * 256 + wav[pos + 2] * 65536 + wav[pos + 3] * 16777216;
                pos += 4 + chunkSize;
            }
            pos += 8;

            // Pos is now positioned to start of actual sound data.
            int samples = (wav.Length - pos) / 2;     // 2 bytes per sample (16 bit sound mono)
            if (channels == 2) samples /= 2;        // 4 bytes per sample (16 bit stereo)

            // Allocate memory (right will be null if only mono sound)
            left = new double[samples];
            if (channels == 2) right = new double[samples];
            else right = null;

            // Write to double array/s:
            int i = 0;
            while (pos < wav.Length)
            {
                left[i] = bytesToDouble(wav[pos], wav[pos + 1]);
                pos += 2;
                if (channels == 2)
                {
                    right[i] = bytesToDouble(wav[pos], wav[pos + 1]);
                    pos += 2;
                }
                i++;
            }
        }

        private double average(double[] values)
        {
            double sum = 0;
            for (int i = 1; i < values.Length; i++)
            {
                sum = sum + Math.Abs(values[i]);
            }
            return sum / values.Length;
        }


        public static DateTime PauseForMilliSeconds(int MilliSecondsToPauseFor)
        {
            System.DateTime ThisMoment = System.DateTime.Now;
            System.TimeSpan duration = new System.TimeSpan(0, 0, 0, 0, MilliSecondsToPauseFor);
            System.DateTime AfterWards = ThisMoment.Add(duration);

            while (AfterWards >= ThisMoment)
            {
                System.Windows.Forms.Application.DoEvents();
                ThisMoment = System.DateTime.Now;
            }

            return System.DateTime.Now;
        }


        //public static string CombinePaths(string path1, params string[] paths)
        //{
        //    if (path1 == null)
        //    {
        //        throw new ArgumentNullException("path1");
        //    }
        //    if (paths == null)
        //    {
        //        throw new ArgumentNullException("paths");
        //    }
        //    return paths.Aggregate(path1, (acc, p) => Path.Combine(acc, p));
        //}

        private string filenaming(int p1, double p2, double p3, double p4, double p5, string SLM)
        {
            string s1 = p1.ToString();
            string s2 = p2.ToString();
            string s3 = p3.ToString();
            string s4 = p4.ToString();
            string s5 = p5.ToString();

            string directory = "C:\\Users\\Polina\\Desktop\\wavFiles\\";
            string wav = ".wav";
            string combination = directory + SLM + "_" + s1 + "_" + s2 + "_" + s3 + "_" + s4 + "_" + s5 + wav;
            return combination;
        }
        **/

        private void label1_Click(object sender, EventArgs e)
        {

        }

        private void label1_Click_1(object sender, EventArgs e)
        {

        }

        private void xyDimLabel_Click(object sender, EventArgs e)
        {

        }

        private void label7_Click(object sender, EventArgs e)
        {

        }

        private void xyDim_TextChanged(object sender, EventArgs e)
        {

        }

        private void imageBox_Click(object sender, EventArgs e)
        {

        }

        private void label19_Click(object sender, EventArgs e)
        {

        }

        private void TestOutput_TextChanged(object sender, EventArgs e)
        {

        }

        private void currentOAM_TextChanged(object sender, EventArgs e)
        {

        }

        private void greenButton_CheckedChanged(object sender, EventArgs e)
        {
            
        }

        private void orangeButton_CheckedChanged(object sender, EventArgs e)
        {
            
        }

        private void redButton_CheckedChanged(object sender, EventArgs e)
        {
            
        }

        private void red_Click_1(object sender, EventArgs e)
        {

        }

        private void green_Click_1(object sender, EventArgs e)
        {

        }

        private void orange_Click_1(object sender, EventArgs e)
        {

        }

        private void frequency3_TextChanged(object sender, EventArgs e)
        {

        }

        private void b3_TextChanged(object sender, EventArgs e)
        {

        }

        private void calibrationCheck_CheckedChanged(object sender, EventArgs e)
        {

        }

        private void OAM_TextChanged(object sender, EventArgs e)
        {

        }

        private void d34_TextChanged(object sender, EventArgs e)
        {

        }

       






    }

    //namespace Tutorial7
    //{
    //        static class Program
    //{
    //    /// <summary>
    //    /// The main entry point for the application.
    //    /// </summary>
    //            [STAThread]
    //            Main()
    //    }
    //}

}
//Phasemask3 does not generate: very negative number issue
//Next steps: execute Program.cs from namespace Tutorial7 to record .wav at same time as testing SLM phasemasks
//Then execute Program.cs from namespace Tutorial10 (on desktop) to read .wav, tabulate amplitude vs. time

